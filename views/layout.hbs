<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Babylon Template</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
  </head>

  <body>
      <canvas id="renderCanvas" touch-action="none"></canvas>
      <script>
        var theme = {
          background: "#006EAF",
          color: 'white',
          lineThickness: 2
        }

        //creates an x, y, z coordinate system using the parameter vec3 for the y axis
        var coordSystem = function(vec3) {  //vec3 non-zero Vector3
          var _y = vec3.normalize();
          if(Math.abs(vec3.x) == 0 && Math.abs(vec3.y) == 0) {
            var _x = new BABYLON.Vector3(vec3.z, 0, 0).normalize();
          }
          else {
            var _x = new BABYLON.Vector3(vec3.y, -vec3.x, 0).normalize();
          }
          var _z = BABYLON.Vector3.Cross(_x, _y);
          return{x:_x, y:_y, z:_z};
        }

        //randomize a value v +/- p*100% of v
        var randPct = function(v, p) {
          if(p==0) {
            return v;
          }

          return (1 + (1 - 2*Math.random())*p)*v;
        }


        /*Creates a single branch of the tree starting from branchAt (Vector3) using the coordinate system branchSys.
        **The branch is in the direction of branchSys.y with the cross section of the branch in the branchSys.x and branchSys.z plane.
        **The branch starts with radius branchRadius and tapers to branchRadius*branchTaper over its length branchLength.
        **The parammeter branchSlices gives the number of cross sectional slices that the branch is divided into
        **The number of bows (bends) in the branch is given by bowFreq and the height of the bow by bowHeight
        */
        var createBranch = function(branchAt, branchSys, branchLength, branchTaper, branchSlices, bowFreq, bowHeight, branchRadius, scene) {
          var _cross_section_paths =  []; //array of paths, each path running along an outer length of the branch
          var _core_point;
          var _core_path = []; //array of Vector3 points that give the path of the central core of the branch
          var _path;
            var _xsr;
            var _radii = []; // array of radii for each core point
            var _theta;
          var _a_sides = 12; //number of sides for each cross sectional polygon slice
          for(var a = 0; a<_a_sides; a++) {
            _cross_section_paths[a] = [];
          }

            var _d_slices_length;

          for(var d = 0; d<branchSlices; d++) {
                _d_slices_length = d/branchSlices;
            _core_point = branchSys.y.scale(_d_slices_length*branchLength); //central point along core path
            //add damped wave along branch to give bows
            _core_point.addInPlace(branchSys.x.scale(bowHeight*Math.exp(-_d_slices_length)*Math.sin(bowFreq*_d_slices_length*Math.PI)));
            //set core point start at spur position.
            _core_point.addInPlace(branchAt);
            _core_path[d] = _core_point;

                //randomize radius by +/- 40% of radius and taper to branchTaper*100% of radius  at top
                _xsr = branchRadius*(1 + (0.4*Math.random() - 0.2))*(1 - (1-branchTaper)*_d_slices_length);
                _radii.push(_xsr);

            //determine the paths for each vertex of the cross sectional polygons
                for(var a = 0; a<_a_sides; a++) {
              _theta = a*Math.PI/6;
                    //path followed by one point on cross section in branchSys.y direction
              _path = branchSys.x.scale(_xsr*Math.cos(_theta)).add(branchSys.z.scale(_xsr*Math.sin(_theta)));
              //align with core
              _path.addInPlace(_core_path[d]);
              _cross_section_paths[a].push(_path);
            }

          }

          //Add cap at end of branch.
          for(var a = 0; a<_a_sides; a++) {
            _cross_section_paths[a].push(_core_path[_core_path.length-1]);
          }


            //Create ribbon mesh to repreent the branch.
            var _branch = BABYLON.MeshBuilder.CreateRibbon("branch", {pathArray: _cross_section_paths, closeArray:true}, scene);

          return {branch:_branch, core:_core_path, _radii:_radii};
        }

        /*
        **Creates a trunk and some branches. This is used as the base of the tree and as the base mesh for an SPS mesh to give additional branches.
        **When boughs = 1 the trunk is created then branches are created at the top of the trunk, the number of branches being given by forks.
        **When boughs = 2 the trunk and branches are created as for boughs = 1, then further branches are created at the end of each of these branches.
        **The parameter forkRatio gives the fraction of branch length as branches are added to branches.
        **The angle of a new branch to the one it is growing from is given by forkAngle.
        */
        var createTreeBase = function(trunkHeight, trunkTaper, trunkSlices, boughs, forks, forkAngle, forkRatio, bowFreq, bowHeight, scene) {
          var _PHI = 2/(1+Math.sqrt(5)); //golden ratio for scale

            var _trunk_direction = new BABYLON.Vector3(0, 1, 0);  //trunk starts in y direction

            var _branch;

          var _trunk_sys = coordSystem(_trunk_direction);
            var _trunk_root_at = new BABYLON.Vector3(0, 0, 0);
            var _tree_branches = []; //Array holding the mesh of each branch
            var _tree_paths = [];  //Array holding the central core points for each branch created
            var _tree_radii = []; //Array holding the branch radius for each brnch created
            var _tree_directions = []; //Array holding the branch direction for each branch created

          var _trunk = createBranch(_trunk_root_at, _trunk_sys, trunkHeight, trunkTaper, trunkSlices, 1, bowHeight, 1, scene); //create trunk
          _tree_branches.push(_trunk.branch);
            var _core_path = _trunk.core;
            _tree_paths.push(_core_path);
            _tree_radii.push(_trunk._radii);
            _tree_directions.push(_trunk_sys);

          var _core_top = _core_path.length - 1;
          var _top_point = _core_path[_core_top];

          var _fork_turn = 2*Math.PI/forks; //angle of spread of forks around a branch

          var _fork_branch_direction, _fork_branchSys;
            var _bough_direction, _bough_sys, _bough_core_path;
          var _turn, _bough_turn, _bough_top, _bough;

            //create new branch at top of trunk for number of forks
            for(var f=0; f<forks; f++) {
            _turn = randPct(f*_fork_turn, 0.25);  //randomise angle of spread for a fork
            _fork_branch_direction = _trunk_sys.y.scale(Math.cos(randPct(forkAngle,0.15))).add(_trunk_sys.x.scale(Math.sin(randPct(forkAngle,0.15))*Math.sin(_turn))).add(_trunk_sys.z.scale(Math.sin(randPct(forkAngle,0.15))*Math.cos(_turn)));
            _fork_branchSys = coordSystem(_fork_branch_direction);
              _branch = createBranch(_top_point, _fork_branchSys, trunkHeight*forkRatio, trunkTaper, trunkSlices, bowFreq, bowHeight*_PHI, trunkTaper, scene);
              _bough_core_path = _branch.core;
              _bough_top = _bough_core_path[_bough_core_path.length - 1];

              //store branch details
              _tree_branches.push(_branch.branch);
              _tree_paths.push(_branch.core);
              _tree_radii.push(_branch._radii);
              _tree_directions.push(_fork_branchSys);
              if(boughs > 1) { // When boughs = 2 create further branches at end of new branch
                  for(var k =0; k<forks; k++) {
                      _bough_turn = randPct(k*_fork_turn, 0.25);
                      _bough_direction = _fork_branchSys.y.scale(Math.cos(randPct(forkAngle,0.15))).add(_fork_branchSys.x.scale(Math.sin(randPct(forkAngle,0.15))*Math.sin(_bough_turn))).add(_fork_branchSys.z.scale(Math.sin(randPct(forkAngle,0.15))*Math.cos(_bough_turn)));
                    _bough_sys = coordSystem(_bough_direction);
                      _bough = createBranch(_bough_top, _bough_sys, trunkHeight*forkRatio*forkRatio, trunkTaper, trunkSlices, bowFreq, bowHeight*_PHI*_PHI, trunkTaper*trunkTaper, scene);

                     //store branch details
                      _tree_branches.push(_bough.branch);
                      _tree_paths.push(_bough.core);
                      _tree_radii.push(_branch._radii);
                      _tree_directions.push(_bough_sys);
                  }
              }
            }
            var _tree = BABYLON.Mesh.MergeMeshes(_tree_branches); //merge branch meshes into a single mesh
            return {tree:_tree, paths:_tree_paths, radii:_tree_radii, directions:_tree_directions};
        }

        /*Primary function that creates the tree.
        **
        ** A base tree is created consisting of a trunk which forks into branches, which then themselves may fork or not.
        ** This base tree is used in two different ways.
        **    1. as the trunk and parent branches for the whole tree.
        **    2. with leaves added as a mini-tree that is added a number of times to the base trunk and parent branches to form the whole tree.
        **
        ** @Param trunkHeight - height of trunk of tree.
        ** @Param trunkTaper - 0< trunkTaper <1 - fraction of starting radius for the end radius of a branch.
        ** @Param trunkSlices - the number of points on the paths used for the ribbon mesh that forms the branch.
        ** @Param trunk material - the material used on all branches.
        ** @Param boughs - 1 or 2 only - the number of times the tree will split into forked branches, 1 trunk splits into branches, 2 these branches also spilt into branches.
        ** @Param forks - 5 or more really slows the generation. The number of branches a branch can split into.
        ** @Param forkAngle - the angle a forked branch makes with its parent branch measured from the direction of the branch.
        ** @Param forkRatio - 0 < forkRatio < 1 - the ratio of the length of a branch to its parent's length.
        ** @Param branches - the number of mini-trees that are randomally added to the tree..
        ** @Param branchAngle - the angle the mini-tree makes with its parent branch from the direction of the branch.
        ** @Param bowFreq - the number of bows (bends) in a branch. A trunk is set to have only one bow.
        ** @Param bowHeight - the height of a bow from the line of direction of the branch.
        ** @Param leavesOnBranch - the number of leaves to be added to one side of a branch.
        ** @Param leafWHRatio - 0 <  leafWHRatio  < 1, closer to 0 longer leaf, closer to 1 more circular.
        ** @Param leafMaterial -material used for all leaves.
        ** @Param scene - BABYLON scene.
        */
        var createTree = function(trunkHeight, trunkTaper, trunkSlices, trunkMaterial, boughs, forks, forkAngle, forkRatio, branches, branchAngle, bowFreq, bowHeight, leavesOnBranch, leafWHRatio, leafMaterial, scene) {
            if(!(boughs ==1 || boughs ==2)) {
                boughs = 1;
            }
            //create base tree
            var _base = createTreeBase(trunkHeight, trunkTaper, trunkSlices, boughs, forks, forkAngle, forkRatio, bowFreq, bowHeight, scene);
            _base.tree.material = trunkMaterial;

            //create one leaf
            var _branch_length = trunkHeight*Math.pow(forkRatio, boughs);
            var _leaf_gap = _branch_length/(2 * leavesOnBranch);
            var _leaf_width = 1.5*Math.pow(trunkTaper, boughs - 1);
            var _leaf = BABYLON.MeshBuilder.CreateDisc("leaf", {radius: _leaf_width/2, tessellation:12, sideOrientation:BABYLON.Mesh.DOUBLESIDE}, scene );

            //create solid particle system for leaves
            var _leaves_SPS = new BABYLON.SolidParticleSystem("leaveSPS", scene, {updatable: false});

            //function to position leaves on base tree
            var _set_leaves = function(particle, i, s) {
                var _a = Math.floor(s/(2*leavesOnBranch));
                if(boughs == 1) {
                    _a++;
                }
                else {
                    _a = 2 + _a % forks + Math.floor(_a / forks)*(forks + 1);
                }
                var _j = s % (2*leavesOnBranch);
                var _g =(_j*_leaf_gap + 3*_leaf_gap/2)/_branch_length;

                var _upper = Math.ceil(trunkSlices*_g);
                if(_upper > _base.paths[_a].length - 1) {
                    _upper = _base.paths[_a].length - 1;
                }
                var _lower = _upper - 1;
                var _gl = _lower/(trunkSlices - 1);
                var _gu = _upper/(trunkSlices - 1);
                var _px = _base.paths[_a][_lower].x  + (_base.paths[_a][_upper].x - _base.paths[_a][_lower].x)*(_g - _gl)/(_gu - _gl);
                var _py = _base.paths[_a][_lower].y  + (_base.paths[_a][_upper].y - _base.paths[_a][_lower].y)*(_g - _gl)/(_gu - _gl);
                var _pz = _base.paths[_a][_lower].z  + (_base.paths[_a][_upper].z - _base.paths[_a][_lower].z)*(_g - _gl)/(_gu - _gl);
                particle.position = new BABYLON.Vector3(_px, _py + (0.6*_leaf_width/leafWHRatio + _base.radii[_a][_upper])*(2*(s % 2) - 1), _pz);
                particle.rotation.z = Math.random()*Math.PI/4 ;
                particle.rotation.y = Math.random()*Math.PI/2 ;
                particle.rotation.z = Math.random()*Math.PI/4 ;
                particle.scale.y = 1/leafWHRatio;
            }

            //add leaf mesh _leaf enough for all the final forked branches
            _leaves_SPS.addShape(_leaf, 2*leavesOnBranch*Math.pow(forks, boughs), {positionFunction:_set_leaves});
            var _leaves = _leaves_SPS.buildMesh(); // mesh of leaves
            _leaves.billboard = true;
            _leaf.dispose();

            //create SPS to use with base tree mesh base.tree
            var _mini_trees_SPS = new BABYLON.SolidParticleSystem("miniSPS", scene, {updatable: false});

            //create SPS to use with leaves mesh
            var _mini_leaves_SPS = new BABYLON.SolidParticleSystem("minileavesSPS", scene, {updatable: false});

            //The mini base trees and leaves added to both the SPS systems have to be positioned at the same places and angles.
            //An array of random angles are formed to be used by both the mini base trees and the leaves
            //when they are added as forks at the end of the final branches.
            var _turns = [];
            var _fork_turn = 2*Math.PI/forks;
            for(var f=0; f<Math.pow(forks, boughs + 1); f++) {
                _turns.push(randPct(Math.floor(f / Math.pow(forks, boughs)) * _fork_turn, 0.2))
            }

            //the _set_mini_trees function positions mini base trees and leaves at the end of base tree branches, one for each of the forks
            var _set_mini_trees = function(particle, i, s) {
                var _a = s % Math.pow(forks, boughs);
                if(boughs == 1) {
                    _a++;
                }
                else {
                    _a = 2 + _a % forks + Math.floor(_a / forks)*(forks + 1);
                }
                var _mini_sys = _base.directions[_a];
                var mini_top = new BABYLON.Vector3(_base.paths[_a][_base.paths[_a].length - 1].x, _base.paths[_a][_base.paths[_a].length - 1].y, _base.paths[_a][_base.paths[_a].length - 1].z);
                var turn = _turns[s];
            var _mini_direction = _mini_sys.y.scale(Math.cos(randPct(forkAngle,0))).add(_mini_sys.x.scale(Math.sin(randPct(forkAngle,0))*Math.sin(turn))).add(_mini_sys.z.scale(Math.sin(randPct(forkAngle,0))*Math.cos(turn)));
                var axis  = BABYLON.Vector3.Cross(BABYLON.Axis.Y, _mini_direction);
                var _theta = Math.acos(BABYLON.Vector3.Dot(_mini_direction, BABYLON.Axis.Y)/_mini_direction.length());
                particle.scale = new BABYLON.Vector3(Math.pow(trunkTaper, boughs + 1), Math.pow(trunkTaper, boughs + 1), Math.pow(trunkTaper, boughs + 1));
                particle.quaternion = BABYLON.Quaternion.RotationAxis(axis, _theta);
                particle.position = mini_top;
            }

            //The mini base trees and leaves added to both the SPS systems have to be positioned at the same places and angles.
            //An array of random positions and angles are formed to be used by both the mini base trees and the leaves
            //when they are added as random mini leafed trees to the forked tree.
            //The random positions are chosen by selecting one of the random paths for a branch and a random point along the branch.
            var _bturns = [];
            var _places =[];
            var _bplen = _base.paths.length;
            var _bp0len = _base.paths[0].length;
            for(var b=0; b<branches; b++) {
                _bturns.push(2*Math.PI*Math.random() - Math.PI);
                _places.push([Math.floor(Math.random()*_bplen), Math.floor(Math.random()*(_bp0len - 1) + 1)] )
            }

            //the _set_branches function positions mini base trees and leaves at random positions along random branches
            var _set_branches = function(particle, i, s) {
                var _a = _places[s][0];
                var _b = _places[s][1];
                var _mini_sys = _base.directions[_a];
                var _mini_place = new BABYLON.Vector3(_base.paths[_a][_b].x, _base.paths[_a][_b].y, _base.paths[_a][_b].z);
                _mini_place.addInPlace(_mini_sys.z.scale(_base.radii[_a][_b]/2));
                var _turn = _bturns[s];
            var _mini_direction = _mini_sys.y.scale(Math.cos(randPct(branchAngle,0))).add(_mini_sys.x.scale(Math.sin(randPct(branchAngle,0))*Math.sin(_turn))).add(_mini_sys.z.scale(Math.sin(randPct(branchAngle,0))*Math.cos(_turn)));
                var _axis  = BABYLON.Vector3.Cross(BABYLON.Axis.Y, _mini_direction);
                var _theta = Math.acos(BABYLON.Vector3.Dot(_mini_direction, BABYLON.Axis.Y)/_mini_direction.length());
                particle.scale = new BABYLON.Vector3(Math.pow(trunkTaper, boughs + 1), Math.pow(trunkTaper, boughs + 1), Math.pow(trunkTaper, boughs + 1));
                particle.quaternion = BABYLON.Quaternion.RotationAxis(_axis, _theta);
                particle.position = _mini_place;

                var testText = 'This is maybe on a branch';

                const treeOffsetX = "150px";
                const treeOffsetY = "-100px";

                {{!-- createTooltip(particle, scene, treeOffsetX, treeOffsetY, testText); --}}
            }

             //add base tree mesh enough for all the final forked branches
            _mini_trees_SPS.addShape(_base.tree, Math.pow(forks, boughs + 1), {positionFunction:_set_mini_trees});

            //add base tree mesh given the number of branches in that parameter.
            _mini_trees_SPS.addShape(_base.tree, branches, {positionFunction:_set_branches});
            var _tree_crown = _mini_trees_SPS.buildMesh(); // form mesh with all mini trees
            _tree_crown.material = trunkMaterial;

            //add leaves mesh enough for all the final forked branches
            _mini_leaves_SPS.addShape(_leaves, Math.pow(forks, boughs + 1), {positionFunction:_set_mini_trees});

            //add leaves mesh given the number of branches in that parameter.
            _mini_leaves_SPS.addShape(_leaves, branches, {positionFunction:_set_branches});
            var _leaves_crown = _mini_leaves_SPS.buildMesh();  //form mesh of all leaves
            _leaves.dispose();
            _leaves_crown.material = leafMaterial;

            //Give the three mesh elements of full tree the same parent.
            var _root = BABYLON.MeshBuilder.CreateBox("", {}, scene);
            _root.isVisible = true;
            _base.tree.parent = _root;
            _tree_crown.parent = _root;
            _leaves_crown.parent = _root;

            return _root;
        }

        const setCamera = () => {
          const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 3, new BABYLON.Vector3(0, 0, 0));

          // Positions the camera overwriting alpha, beta, radius
          camera.setPosition(new BABYLON.Vector3(0, 30, 50));

          camera.attachControl(canvas, true);
          camera.lowerRadiusLimit = 2; //The upper limit of the camera's reduced radius limits the distance of the camera from the focus
          camera.upperRadiusLimit = 10; //The upper limit of camera magnification radius upperRadiusLimit should not be less than lowerRadiusLimit to avoid errors or ineffectiveness.
          camera.wheelDeltaPercentage = 0.09; //Mouse wheel sensitivity
          camera.checkCollisions = true; // Turn on the collision between perspective and scene objects
          camera.upperBetaLimit = (Math.PI / 2) * 0.9; // Maximum beta angle of viewing angle
          camera.lowerRadiusLimit = 50; // Minimum distance of viewing angle
          camera.upperRadiusLimit = 1000; // Maximum distance of viewing angle
          camera.radius = 100; // Initialize the viewing angle distance

          {{!-- camera.useAutoRotationBehavior = true; --}}
          // camera.autoRotationBehavior.idleRotationSpeed = 0.2;

          camera.useFramingBehavior = true;
          camera.framingBehavior.radiusScale = 50;

          return camera;
        }

        const setGround = () => {
          const ground = BABYLON.MeshBuilder.CreateGround("ground", {
            width: 300,
            height: 300
          });
          const groundMat = new BABYLON.StandardMaterial("groundMat");
          groundMat.diffuseColor = BABYLON.Color3.FromHexString("#585E43")
          ground.material = groundMat;

          return ground;
        }

        var createButton = function(tree, text, verticalOffset, treesToHide) {
          // GUI
          var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

          var button = BABYLON.GUI.Button.CreateSimpleButton("but1", text);
          button.width = "150px"
          button.height = "40px";
          button.color = theme.color;
          button.cornerRadius = 5;
          button.background = theme.background;
          treesToHide.forEach((hideTree) => {
            button.onPointerUpObservable.add(function() {
              hideTree.setEnabled(false);
            });
          });
          button.onPointerUpObservable.add(function() {
            tree.setEnabled(true);
          });
          button.top = verticalOffset;
          button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
          button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
          advancedTexture.addControl(button);
        }

        var createTooltip = function(mesh, scene, offsetX, offsetY, tooltipText) {
          // GUI
          var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
          advancedTexture.isForeground = true;
          advancedTexture.useInvalidateRectOptimization = false;

          let textBox1 = new BABYLON.GUI.Rectangle();
          advancedTexture.addControl(textBox1);
          textBox1.width = "300px";
          textBox1.height ="200px";
          textBox1.thickness = theme.lineThickness;

          // Where the tooltip will show up
          textBox1.linkOffsetX = offsetX;
          textBox1.linkOffsetY = offsetY;

          textBox1.transformCenterX = 0;
          textBox1.transformCenterY = 1;
          textBox1.background = theme.background;

          textBox1.alpha = 0.7;
          textBox1.scaleX = 0;
          textBox1.scaleY = 0;
          textBox1.cornerRadius = 5
          textBox1.linkWithMesh(mesh);

          let text1 = new BABYLON.GUI.TextBlock();
          text1.text = tooltipText || "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Id consectetur purus ut faucibus pulvinar. Placerat vestibulum lectus mauris ultrices. Arcu cursus euismod quis viverra nibh cras pulvinar mattis nunc. Quisque id diam vel quam elementum pulvinar. Imperdiet sed euismod nisi porta. Habitasse platea dictumst quisque sagittis purus sit amet. Neque egestas congue quisque egestas diam in. Facilisis volutpat est velit egestas dui id ornare arcu odio. Faucibus ornare suspendisse sed nisi lacus sed viverra tellus in. Eu facilisis sed odio morbi quis commodo odio. Dolor sit amet consectetur adipiscing elit ut aliquam. Tristique senectus et netus et malesuada. Nibh venenatis cras sed felis.";
          text1.color = theme.color;
          text1.fontSize = 14;
          text1.fontFamily = "monospace";
          text1.textWrapping = true;
          text1.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
          text1.background = '#006994'
          textBox1.addControl(text1)
          text1.alpha = (1/text1.parent.alpha);
          text1.paddingTop = "20px";
          text1.paddingBottom = "20px";
          text1.paddingLeft = "20px";
          text1.paddingRight = "20px";

          let actionManager = new BABYLON.ActionManager(scene);
          mesh.actionManager = actionManager;

          let scaleXAnimation = new BABYLON.Animation("myAnimation", "scaleX", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
          let scaleYAnimation = new BABYLON.Animation("myAnimation", "scaleY", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);

          var keys = [];

          keys.push({
            frame: 0,
            value: 0
          });

          keys.push({
            frame: 10,
            value: 1
          });

          scaleXAnimation.setKeys(keys);
          scaleYAnimation.setKeys(keys);
          textBox1.animations = [];
          textBox1.animations.push(scaleXAnimation);
          textBox1.animations.push(scaleYAnimation);

          actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOverTrigger, function(ev){
            scene.beginAnimation(textBox1, 0, 10, false);
          }));
          //if hover is over remove highlight of the mesh
          actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOutTrigger, function(ev){
            scene.beginAnimation(textBox1, 10, 0, false);
          }));

          return scene;
        }

        var createAttachedTooltip = function(mesh, scene, toolTipText) {
          var tooltip = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
          var offset = 300;

          // shape of tooltip
          var rect1 = new BABYLON.GUI.Rectangle();
          rect1.width = 0.2;
          rect1.height = "40px";
          rect1.cornerRadius = 5;
          rect1.color = theme.color;
          rect1.thickness = theme.lineThickness;
          rect1.background = theme.background;
          tooltip.addControl(rect1);
          rect1.linkWithMesh(mesh);
          rect1.linkOffsetY = -offset;

          {{!-- rect1.linkOffsetX = "60px"; --}}

          // text in rectangular label
          var label = new BABYLON.GUI.TextBlock();
          label.text = toolTipText;
          rect1.addControl(label);

          // circle target
          var target = new BABYLON.GUI.Ellipse();
          target.width = "40px";
          target.height = "40px";
          target.color = theme.color;
          target.thickness = theme.lineThickness;
          target.background = theme.background;
          target.linkOffsetY = 150 - offset;
          tooltip.addControl(target);
          target.linkWithMesh(mesh);

          // line connecting target and tooltip
          var line = new BABYLON.GUI.Line();
          line.lineWidth = 4;
          line.color = theme.color;
          line.y2 = 20;
          line.linkOffsetY = -(offset-130);
          tooltip.addControl(line);
          line.linkWithMesh(mesh);
          line.connectedControl = rect1;

          return scene;
        };

        var createScene = function() {
          // TODO: Start here for initialization

          // Initialize Scene
          const scene = new BABYLON.Scene(engine);

          const camera = setCamera();

          // Lighting
          const light = new BABYLON.HemisphericLight(
            "light",
            new BABYLON.Vector3(0, 1, 0)
          );

          setGround();

          //trunk and branch material
          var bark = new BABYLON.StandardMaterial("bark", scene);
          bark.emissiveTexture = new BABYLON.Texture("https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Bark_texture_wood.jpg/800px-Bark_texture_wood.jpg", scene);
          bark.diffuseTexture = new BABYLON.Texture("https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Bark_texture_wood.jpg/800px-Bark_texture_wood.jpg", scene);
          bark.diffuseTexture.uScale = 2.0;//Repeat 5 times on the Vertical Axes
          bark.diffuseTexture.vScale = 2.0;//Repeat 5 times on the Horizontal Axes

          // Tree0
          var trunkHeight = 20;
          var trunkTaper = 0.6;
          var trunkSlices = 5;
          var boughs = 2; // 1 or 2
          var forks = 4;
          var forkAngle = Math.PI/4;
          var forkRatio = 2/(1+Math.sqrt(5)); //PHI the golden ratio
          var branchAngle = Math.PI/3;
          var bowFreq = 2;
          var bowHeight = 3.5;
          var branches = 10;
          var leavesOnBranch = 5;
          var leafWHRatio = 0.5;
          //leaf material
          var leafMaterial = new BABYLON.StandardMaterial(
            "leafMaterial",
            scene
          );
          leafMaterial.diffuseColor = new BABYLON.Color3(0,1,0);
          const tree0 = createTree(
            trunkHeight,
            trunkTaper,
            trunkSlices,
            bark,
            boughs,
            forks,
            forkAngle,
            forkRatio,
            branches,
            branchAngle,
            bowFreq,
            bowHeight,
            leavesOnBranch,
            leafWHRatio,
            leafMaterial,
            scene
          );
          tree0.position.x = -35
          tree0.position.y = 0

          // Tree 1
          var trunkHeight = 20;
          var trunkTaper = 0.6;
          var trunkSlices = 5;
          var boughs = 2; // 1 or 2
          var forks = 4;
          var forkAngle = Math.PI/4;
          var forkRatio = 2/(1+Math.sqrt(5)); //PHI the golden ratio
          var branchAngle = Math.PI/3;
          var bowFreq = 2;
          var bowHeight = 3.5;
          var branches = 10;
          var leavesOnBranch = 5;
          var leafWHRatio = 0.5;
          //leaf material
          var leafMaterial = new BABYLON.StandardMaterial(
            "leafMaterial",
            scene
          );
          leafMaterial.diffuseColor = new BABYLON.Color3(0,1,0);
          const tree1 = createTree(
            trunkHeight,
            trunkTaper,
            trunkSlices,
            bark,
            boughs,
            forks,
            forkAngle,
            forkRatio,
            branches,
            branchAngle,
            bowFreq,
            bowHeight,
            leavesOnBranch,
            leafWHRatio,
            leafMaterial,
            scene
          );
          tree1.position.x = 0
          tree1.position.y = 0
          tree1.setEnabled(false);


          // Tree2
          var trunkHeight = 20;
          var trunkTaper = 0.6;
          var trunkSlices = 5;
          var boughs = 2; // 1 or 2
          var forks = 4;
          var forkAngle = Math.PI/4;
          var forkRatio = 2/(1+Math.sqrt(5)); //PHI the golden ratio
          var branchAngle = Math.PI/3;
          var bowFreq = 2;
          var bowHeight = 3.5;
          var branches = 10;
          var leavesOnBranch = 5;
          var leafWHRatio = 0.5;
          //leaf material
          var leafMaterial = new BABYLON.StandardMaterial(
            "leafMaterial",
            scene
          );
          leafMaterial.diffuseColor = new BABYLON.Color3(0,1,0);
          const tree2 = createTree(
            trunkHeight,
            trunkTaper,
            trunkSlices,
            bark,
            boughs,
            forks,
            forkAngle,
            forkRatio,
            branches,
            branchAngle,
            bowFreq,
            bowHeight,
            leavesOnBranch,
            leafWHRatio,
            leafMaterial,
            scene
          );
          tree2.position.x = 35
          tree2.position.y = 0
          tree2.setEnabled(false);

          // Tree3
          var trunkHeight = 20;
          var trunkTaper = 0.6;
          var trunkSlices = 5;
          var boughs = 2; // 1 or 2
          var forks = 4;
          var forkAngle = Math.PI/4;
          var forkRatio = 2/(1+Math.sqrt(5)); //PHI the golden ratio
          var branchAngle = Math.PI/3;
          var bowFreq = 2;
          var bowHeight = 3.5;
          var branches = 10;
          var leavesOnBranch = 5;
          var leafWHRatio = 0.5;
          //leaf material
          var leafMaterial = new BABYLON.StandardMaterial(
            "leafMaterial",
            scene
          );
          leafMaterial.diffuseColor = new BABYLON.Color3(0,1,0);
          const tree3 = createTree(
            trunkHeight,
            trunkTaper,
            trunkSlices,
            bark,
            boughs,
            forks,
            forkAngle,
            forkRatio,
            branches,
            branchAngle,
            bowFreq,
            bowHeight,
            leavesOnBranch,
            leafWHRatio,
            leafMaterial,
            scene
          );
          tree3.position.x = 70
          tree3.position.y = 0
          tree3.position.z = 35
          tree3.setEnabled(false);

          // Tree4
          var trunkHeight = 20;
          var trunkTaper = 0.6;
          var trunkSlices = 5;
          var boughs = 2; // 1 or 2
          var forks = 4;
          var forkAngle = Math.PI/4;
          var forkRatio = 2/(1+Math.sqrt(5)); //PHI the golden ratio
          var branchAngle = Math.PI/3;
          var bowFreq = 2;
          var bowHeight = 3.5;
          var branches = 10;
          var leavesOnBranch = 5;
          var leafWHRatio = 0.5;
          //leaf material
          var leafMaterial = new BABYLON.StandardMaterial(
            "leafMaterial",
            scene
          );
          leafMaterial.diffuseColor = new BABYLON.Color3(0,1,0);
          const tree4 = createTree(
            trunkHeight,
            trunkTaper,
            trunkSlices,
            bark,
            boughs,
            forks,
            forkAngle,
            forkRatio,
            branches,
            branchAngle,
            bowFreq,
            bowHeight,
            leavesOnBranch,
            leafWHRatio,
            leafMaterial,
            scene
          );
          tree4.position.x = 70;
          tree4.position.y = 0;
          tree4.position.z = -35;
          tree4.setEnabled(false);

          camera.setTarget(tree1);

          const treeOffsetX = "150px";
          const treeOffsetY = "-100px";

          // tooltips
          var tree0Text = "This is the first tree";
          var tree1Text = "This is the second tree";
          var tree2Text = "This is the third tree";
          var tree3Text = "This is the fourth tree";
          var tree4Text = "This is the fifth tree";

          createTooltip(tree0, scene, treeOffsetX, treeOffsetY, tree0Text);
          createTooltip(tree1, scene, treeOffsetX, treeOffsetY, tree1Text);
          createTooltip(tree2, scene, treeOffsetX, treeOffsetY, tree2Text);
          createTooltip(tree3, scene, treeOffsetX, treeOffsetY, tree3Text);
          createTooltip(tree4, scene, treeOffsetX, treeOffsetY, tree4Text);

          // another option for tooltip
          {{!-- createAttachedTooltip(tree0, scene, tree0Text);
          createAttachedTooltip(tree1, scene, tree1Text);
          createAttachedTooltip(tree2, scene, tree2Text);
          createAttachedTooltip(tree3, scene, tree3Text);
          createAttachedTooltip(tree4, scene, tree4Text); --}}

          // sample buttons
          createButton(tree0, 'Tree 1', 0, [tree1, tree2, tree3, tree4]);
          createButton(tree1, 'Tree 2', -50, [tree0, tree2, tree3, tree4]);
          createButton(tree2, 'Tree 3', -100, [tree0, tree1, tree3, tree4]);
          createButton(tree3, 'Tree 4', -150, [tree0, tree1, tree2, tree4]);
          createButton(tree4, 'Tree 5', -200, [tree0, tree1, tree2, tree3]);

          return scene;
        };

        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
        // Add your code here matching the playground format
        const scene = createScene(); //Call the createScene function
        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
                scene.render();
        });
        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
      </script>
  </body>
</html>
